---
title: "Vertical Jump Analysis"
output: 
  flexdashboard::flex_dashboard
runtime: shiny
editor_options:
    chunk_output_type: console
---

```{r global, include=FALSE}
library(flexdashboard) # Required for dashboard functionality
library(purrr) # Fast index location finding
library(signal) # Filter application
library(data.table) # Data manipulation
library(plotly) # Pretty plots
library(zoo) # Rolling mean filter
library(changepoint) # Detection of changes in the mean
library(pracma) # Trapezoidal integration for net impulse
library(shinyWidgets) # Dropdown menus
library(kableExtra) # Variable table styling

options(shiny.maxRequestSize = 40 * 1024 ^ 2) # Accepts files up to 40 mB in size; adjust based on your file size requirements

# Function for plotting vertical lines on plots since plotly doesn't natively do vlines
vline <- function(x = 0, color = "black"){
  list(
    type = "line",
    y0 = 0,
    y1 = 1,
    yref = "paper",
    x0 = x,
    x1 = x,
    line = list(color = color,
                dash = "dot",
                width = 1)
  )
}
```

Inputs {.sidebar}
----------
```{r upload_handler, echo=FALSE}
# Currently set to accept .csv and .txt outputs from Pasco Capstone. In theory, this should be easy to extend to other collection methods
# The important thing is that your .csv or .txt file has two rows before your data; row one can be filler, to be honest, whereas
# row two should contain variable names. Each column containing VGRF data should be named some variant of "Normal Force" as the grepl
# function below specifically searches for "Normal" in your uploaded file and keeps any columns containing "Normal"
# Importantly, your trials should be organized column-wise. That is, columns 1, 2, 3, 4... should be fp1_1, fp2_1, fp1_2, fp2_2...
fileInput(inputId = "jump_file_upload", label = "Upload Jump Data", multiple = FALSE, accept = c(".csv", ".txt"))
numericInput(inputId = "trial_number", "Select Trial", value = 1, min = 1, max = 25, step = 1)

dropdownButton(
  dateInput(inputId = "jump_date", label = "Select Testing Date", weekstart = 1, width = "100%"),
  textInput(inputId = "athlete_name", label = "Enter Athlete Name", width = "100%"),
  selectInput(inputId = "jump_type", label = "Select Jump Type", choices = c("Automatic" = "auto",
                                                                             "Squat Jump" = "sj",
                                                                             "Countermovement Jump" = "cmj"), width = "100%"),
  numericInput(inputId = "bar_load", "Enter Bar Load (if any)", value = 0, width = "100%"),
  circle = FALSE, status = "primary", label = "Descriptive Information")
HTML("<br>")
dropdownButton(
  numericInput(inputId = "sampling_frequency", label = "Sampling Frequency", value = 1000, width = "100%"),
  numericInput(inputId = "quiet_length", label = "Quiet Standing Length", value = 0.5, min = 0.2, max = 1, step = 0.1, width = "100%"),
  numericInput(inputId = "fp1_slope", label = "FP1 Slope", value = 1, width = "100%"),
  numericInput(inputId = "fp1_intercept", label = "FP1 Intercept", value = 0, width = "100%"),
  numericInput(inputId = "fp2_slope", label = "FP2 Slope", value = 1, width = "100%"),
  numericInput(inputId = "fp2_intercept", label = "FP2 Intercept", value = 0, width = "100%"),
  selectInput(inputId = "filter_type", label = "Apply Filter?", choices = c("None" = "no_filter",
                                                                            "Butterworth" = "butt_filter",
                                                                            "Moving Avg" = "moving_avg"), width = "100%"),
  circle = FALSE, status = "primary", label = "Force Plate Adjustments")
HTML("<br>")
actionBttn(inputId = "save_trial", label = "Save Current Trial", icon = icon("save"), style = "material-flat", color = "primary")

jump_information <- reactiveValues() # Where the magic happens; stores data and allows them to be passed between functions

# This is the actual listener for file uploads; parses the data, passes them to the reactiveValues above, and sets the maximum
# number of trials available in the numericInput for trial number
observe({
  req(input$jump_file_upload)
  jump_information$data <- NULL
  
  jump_data <- fread(input$jump_file_upload$datapath,
                     header = TRUE,
                     na.strings = c("", "NA"),
                     stringsAsFactors = FALSE,
                     skip = 1)
  names(jump_data) <- make.names(names(jump_data), unique = TRUE)
  jump_data <- jump_data[, grepl("Normal", names(jump_data)), with = FALSE]
  trial_number <- ncol(jump_data) / 2
  updateNumericInput(session, inputId = "trial_number", value = 1, max = trial_number)
  
  jump_information$data <- jump_data
})

# Waits for you to click the save button in the sidebar and saves the currently selected trial
# Creates a folder called Analyses in your current working directory (if it doesn't exist) and creates a file to store the data
# based on the date you have entered
observeEvent(input$save_trial, {
  req(jump_information$bilateral_variables)
  req(jump_information$unilateral_variables)
  
  jump_date <- input$jump_date
  athlete <- input$athlete_name
  jump_type <- jump_information$jump_type
  trial <- input$trial_number
  bar_load <- input$bar_load
  body_mass <- jump_information$body_mass
  
  variable_table <- data.table(jump_date, athlete, jump_type, trial, bar_load, body_mass)
  variable_table <- cbind(variable_table, jump_information$bilateral_variables)
  variable_table <- cbind(variable_table, jump_information$unilateral_variables)
  if(jump_information$jump_type == "cmj")
    variable_table <- cbind(variable_table, jump_information$phase_variables)
  
  if(!dir.exists("Analyses"))
    dir.create("Analyses")
  if(!file.exists(file.path("Analyses", paste0(jump_date, " Jump Analysis.csv")))){
    headers <- t(c("jump_date", "athlete", "jump_type", "trial", "bar_load", "body_mass", "jh_ft", "jh_ni", "flight_time", "net_impulse",
                   "takeoff_velocity", "peak_force", "peak_velocity", "peak_power", "fpp", "vpp", "ttpf", "avg_rfd", "contact_time",
                   "rsi_mod", "f_zero_velo", "fp1_ni", "fp2_ni", "ni_si", "fp1_pf", "fp2_pf", "pf_si", "fp1_ttpf", "fp2_ttpf", "ttpf_si",
                   "fp1_avg_rfd", "fp2_avg_rfd", "avg_rfd_si", "unweight_duration", "braking_duration", "concentric_duration"))
    fwrite(headers, file.path("Analyses", paste0(jump_date, " Jump Analysis.csv")), append = FALSE, col.names = FALSE)
  }
  fwrite(variable_table, file.path("Analyses", paste0(jump_date, " Jump Analysis.csv")), append = TRUE)
})
```

```{r data_manipulation, echo=FALSE}
jump_information$trial_brush <- NULL # Required for plot brushing and resetting on the next line
# Without this observer, the app retains the last plot brush, which leads to incorrect/erroneous data selection
# and crashes if the selection falls outside the data available
observe({
  if(is.null(event_data(source = "plot_brush", event = "plotly_brushed")$x))
    jump_information$trial_brush <- NULL
  else
    jump_information$trial_brush <- round(event_data(source = "plot_brush", event = "plotly_brushed")$x * 1000, 0)
})
# Re-runs on newly uploaded data or when selecting a new trial
observeEvent({
  jump_information$data
  input$trial_number
},
{
  req(jump_information$data)
  req(input$trial_number) # Prevents crashes from clearing the "Select Trial" input
  
  if(!is.null(jump_information$trial_brush)){
    jump_information$trial_brush <- NULL
  }
  
  data <- jump_information$data
  selected_trial <- input$trial_number
  fp1_slope <- input$fp1_slope
  fp1_intercept <- input$fp1_intercept
  fp2_slope <- input$fp2_slope
  fp2_intercept <- input$fp2_intercept
  filter_type <- input$filter_type
  sampling_frequency <- input$sampling_frequency
  
  fp1 <- selected_trial * 2 - 1
  fp2 <- selected_trial * 2
  
  if(fp1 > ncol(data)){ # In case you've uploaded a new file with fewer trials than your previous file
    # This prevents the app from crashing when the number in the
    return() # trial selection box is greater than the number available; may add a slight delay to processing new files
  }
  
  trial_data <- na.omit(data[, fp1:fp2]) # We only want to retain the columns for the respective trial
  setnames(trial_data, c("fp1", "fp2")) # And want to rename them from what the upload handler named them
  trial_data[, ":=" (fp1 = fp1 * fp1_slope + fp1_intercept,
                     fp2 = fp2 * fp2_slope + fp2_intercept)] # Adjust the force plate force data based on calibration you've performed
  
  if(filter_type != "no_filter"){ # Default is no filter, but two filter options are currently implemented
    if(filter_type == "butt_filter"){ # First is a 2nd order low-pass Butterworth filter with a cutoff frequency of 10Hz
      data_filter <- signal::butter(2, 10 / (0.5 * sampling_frequency), "low") # Change the 2 for different order and 10 for different cutoff freq
      
      trial_data <- trial_data[, lapply(.SD, function(x) filtfilt(data_filter, x)) # Applies the filter created above
                               ][, total_force := fp1 + fp2]
    }
    else{
      trial_data <- trial_data[, lapply(.SD, function(x) rollapplyr(x, 10, mean, partial = TRUE)) # Second option is a 10-point moving average
                               ][, total_force := fp1 + fp2] # Again, change the 10 to adjust the filter window size
    }
  }
  else
    trial_data[, total_force := fp1 + fp2]
  
  jump_information$trial_data <- trial_data
})
```

```{r event_detection, echo=FALSE}
observe({
  req(jump_information$trial_data)
  
  threshold <- 10 # Threshold for takeoff and landing; adjust accordingly
  sampling_frequency <- input$sampling_frequency
  data <- jump_information$trial_data
  if(!is.null(jump_information$trial_brush)){ # Checks if you've brushed the full trial plot
    trial_brush <- jump_information$trial_brush # If so, constrains the data to your selection
    data <- data[trial_brush[1]:trial_brush[2]]
  }
  
  # Finds primary "changepoints" or breakpoints in the data; points where the mean changes for a minimum of 200 ms
  # In theory, this could find quiet standing, jump initiation, peak force, flight, and landing, but is a little too unreliable for my taste
  # Instead, the changepoints are bound together into sequential pairs and the pair with the lowest average force between them is identified
  # as the flight time range. To remove ringing, however, the first and last 25% are trimmed before calculating the average force
  # to offset the data
  changepoints <- cpt.mean(data$total_force, method = "BinSeg", class = FALSE, minseglen = 200 * (sampling_frequency / 1000))
  changepoints <- data.table(cbind(cp1 = changepoints, cp2 = c(changepoints[-1], changepoints[1])))
  cpt_means <- data.table(cp1 = NULL, cp2 = NULL, avg_force = NULL)
  for(c in 1:(nrow(changepoints) - 1)){
    mean_force <- data[1:nrow(data) %between% changepoints[c, .(cp1, cp2)], mean(total_force)]
    cpt_means <- rbind(cpt_means, c(changepoints[c, .(cp1, cp2)], mean_force = mean_force))
  }
  cpt_flight <- cpt_means[, .SD[which.min(mean_force)]] # Return all columns for the row with the lowest mean force; theoretically unloaded plate
  cpt_flight[, width := cp2 - cp1][, ":=" (new_cp1 = cp1 + 0.25 * width, new_cp2 = cp2 - 0.25 * width)] # Trims 50% from above changepoint
  offsets <- data[1:nrow(data) %between% cpt_flight[, .(new_cp1, new_cp2)], # Grabs the data between the above changepoints
                  .(fp1_offset = mean(fp1), fp2_offset = mean(fp2), total_force_offset = mean(total_force))] # Calculates the means
  # to then offset the force-time data for each plate and for the total force
  data[, ":=" (fp1 = fp1 - offsets$fp1_offset, fp2 = fp2 - offsets$fp2_offset, total_force = total_force - offsets$total_force_offset)]
  
  peak_force_index <- which.max(data[1:cpt_flight$cp1, total_force]) # Finds where peak force occurs; used elsewhere
  # Location of peak landing force; not currently implemented other than for visual purposes
  # 1 is subtracted since R is indexed on 1; that is, it starts counting at 1, so we need to subtract one from the
  # index value to line it up correctly
  peak_landing_force_index <- which.max(data[cpt_flight$new_cp2:nrow(data), total_force]) + cpt_flight$new_cp2 - 1
  # 2 is subtracted here, though, since we want the final data point at which the athlete was still on the force plate
  takeoff_index <- detect_index(data[peak_force_index:cpt_flight$new_cp1, total_force], ~ .x <= threshold) + peak_force_index - 2
  # Since R is indexed on 1, the value returned here actually coincides with the first instant the athlete passes the force threshold
  landing_index <- detect_index(data[cpt_flight$new_cp2:peak_landing_force_index, 
                                     total_force], ~ .x <= threshold, .dir = "backward") + cpt_flight$new_cp2
  
  jump_information$offset_data <- data
  jump_information$peak_force_index <- peak_force_index
  jump_information$peak_landing_force_index <- peak_landing_force_index
  jump_information$takeoff_index <- takeoff_index
  jump_information$landing_index <- landing_index
})
```

```{r jump_initiation_detection, echo=FALSE}
observe({
  req(jump_information$offset_data)
  
  data <- jump_information$offset_data
  sampling_frequency <- input$sampling_frequency
  quiet_standing_length <- input$quiet_length
  peak_force_index <- jump_information$peak_force_index
  takeoff_index <- jump_information$takeoff_index
  landing_index <- jump_information$landing_index
  peak_landing_force_index <- jump_information$peak_landing_force_index
  
  quiet_standing <- data[1:(sampling_frequency * quiet_standing_length)] # Used for weighing the athlete; length can be adjusted in the sidebar
  body_weight <- quiet_standing[, mean(total_force)] # Calculates mean...
  body_weight_sd <- quiet_standing[, sd(total_force)] # ...and SD for the quiet standing portion; this is used for the jump initiation process
  
  pre_peak_minimum_force <- data[1:peak_force_index, min(total_force)] # Used to determine if we're dealing with SJ or CMJ
  if(input$jump_type == "auto")
    if(body_weight - pre_peak_minimum_force > 250) # Arbitrarily chose 250 newtons as the delineation between SJ and CMJ; may need to be adjusted
      jump_type <- "cmj"
  else
    jump_type <- "sj"
  else
    jump_type <- input$jump_type
  
  # detect_index finds the first point exceeding (SJ) or falling below (CMJ) the threshold calculated from the quiet standing portion above
  # Since it's searching in reverse, we need to add 1 in this case; we move back an additional 30ms based on recommendations from the literature
  if(jump_type == "sj"){
    initiation_threshold <- body_weight + body_weight_sd * 5
    jump_start_index <- detect_index(data[1:peak_force_index, total_force], 
                                     ~ .x <= initiation_threshold, .dir = "backward") + 1 - 30 * (sampling_frequency / 1000)
  }
  else{
    initiation_threshold <- body_weight - body_weight_sd * 5
    minimum_force_index <- which.min(data[1:peak_force_index, total_force])
    jump_start_index <- detect_index(data[1:minimum_force_index, total_force],
                                     ~ .x >= initiation_threshold, .dir = "backward") + 1 - 30 * (sampling_frequency / 1000)
  }
  jump_information$body_weight <- body_weight
  jump_information$body_mass <- body_weight / 9.81
  jump_information$jump_type <- jump_type
  jump_information$jump_start_index <- jump_start_index
})
```

```{r bilateral_analyses, echo=FALSE}
observe({
  req(jump_information$offset_data)
  
  data <- jump_information$offset_data
  sampling_frequency <- input$sampling_frequency
  jump_type <- jump_information$jump_type
  jump_start_index <- jump_information$jump_start_index
  peak_force_index <- jump_information$peak_force_index
  takeoff_index <- jump_information$takeoff_index
  landing_index <- jump_information$landing_index
  body_weight <- jump_information$body_weight
  body_mass <- jump_information$body_mass
  
  data <- data[jump_start_index:takeoff_index]
  
  data[, net_impulse := cumtrapz(1:nrow(data), total_force - body_weight) / sampling_frequency] # Thank God for pracma
  data[, velocity := net_impulse / body_mass][, power := total_force * velocity]
  
  peak_power_index <- which.max(data[, power]) # Used to find forcer at peak power, etc. below
  
  jump_height_ft <- 0.5 * 9.81 * ((landing_index - takeoff_index) / sampling_frequency / 2) ^ 2
  jump_height_ni <- data[, last(velocity)] ^ 2 / (2 * 9.81) # last() finds takeoff velocity
  flight_time <- (landing_index - takeoff_index) / sampling_frequency
  net_impulse <- data[, last(net_impulse)]
  takeoff_velocity <- data[, last(velocity)]
  peak_force <- data[, max(total_force)]
  peak_velocity <- data[, max(velocity)]
  peak_power <- data[, max(power)]
  force_peak_power <- data[peak_power_index, total_force]
  velocity_peak_power <- data[peak_power_index, velocity]
  time_to_peak_force <- which.max(data[, total_force]) / sampling_frequency
  avg_rfd <- (peak_force - data[, first(total_force)]) / time_to_peak_force
  contact_time <- nrow(data) / sampling_frequency
  rsi_modified <- jump_height_ni / contact_time
  
  variable_table <- data.table(jump_height_ft, jump_height_ni, flight_time, net_impulse, takeoff_velocity,
                               peak_force, peak_velocity, peak_power, force_peak_power, velocity_peak_power,
                               time_to_peak_force, avg_rfd, contact_time, rsi_modified)
  if(jump_type == "cmj"){
    # peak_force and jump_start_index are both indexed on the original dataset, so we need to do some subtraction to find the proper index
    # value in the current data; used to find minimum force after jump initiation and before peak force
    minimum_force_index <- which.min(data[1:(peak_force_index - jump_start_index), total_force])
    # Searches from minimum force to find the point at which velocity is zero (it's been negative up to this point); subtract 2 and then
    # add the index to find the proper location in the dataset; final point where velocity is < 0
    zero_velo_index <- detect_index(data[minimum_force_index:nrow(data), velocity],
                                    ~ .x >= 0, .dir = "forward") - 2 + minimum_force_index
    force_zero_velo <- data[zero_velo_index, total_force]
    variable_table <- cbind(variable_table, force_zero_velo)
  }
  jump_information$bilateral_data <- data
  jump_information$bilateral_variables <- variable_table
})
```

```{r unilateral_analyses, echo=FALSE}
# Performs the same analyses as above; this time, however, the variables are constrained to net impulse, peak force, avg RFD, etc.
# Also calculates symmetry index values for each of the variables; positive SI favor fp1, negative favors fp2
observe({
  req(jump_information$offset_data)
  
  data <- jump_information$offset_data
  sampling_frequency <- input$sampling_frequency
  jump_type <- jump_information$jump_type
  quiet_standing_length <- input$quiet_length
  jump_start_index <- jump_information$jump_start_index
  takeoff_index <- jump_information$takeoff_index
  landing_index <- jump_information$landing_index
  
  quiet_standing <- data[1:(sampling_frequency * quiet_standing_length)]
  fp1_weight <- quiet_standing[, mean(fp1)]
  fp2_weight <- quiet_standing[, mean(fp2)]
  
  data <- data[jump_start_index:takeoff_index]
  
  data[, ":=" (fp1_net_impulse = cumtrapz(1:nrow(data), fp1 - fp1_weight) / sampling_frequency,
               fp2_net_impulse = cumtrapz(1:nrow(data), fp2 - fp2_weight) / sampling_frequency)]
  
  fp1_net_impulse <- data[, last(fp1_net_impulse)]
  fp2_net_impulse <- data[, last(fp2_net_impulse)]
  net_impulse_symmetry_index <- (fp1_net_impulse - fp2_net_impulse) / mean(c(fp1_net_impulse, fp2_net_impulse)) * 100
  fp1_peak_force <- data[, max(fp1)]
  fp2_peak_force <- data[, max(fp2)]
  peak_force_symmetry_index <- (fp1_peak_force - fp2_peak_force) / mean(c(fp1_peak_force, fp2_peak_force)) * 100
  fp1_peak_force_index <- which.max(data[, fp1])
  fp2_peak_force_index <- which.max(data[, fp2])
  fp1_time_to_peak_force <- fp1_peak_force_index / sampling_frequency
  fp2_time_to_peak_force <- fp2_peak_force_index / sampling_frequency
  time_to_peak_force_symmetry_index <- (fp1_time_to_peak_force - fp2_time_to_peak_force) / mean(c(fp1_time_to_peak_force, fp2_time_to_peak_force)) * 100
  fp1_avg_rfd <- fp1_peak_force / fp1_time_to_peak_force
  fp2_avg_rfd <- fp2_peak_force / fp2_time_to_peak_force
  avg_rfd_symmetry_index <- (fp1_avg_rfd - fp2_avg_rfd) / mean(c(fp1_avg_rfd, fp2_avg_rfd)) * 100
  
  variable_table <- data.table(fp1_net_impulse, fp2_net_impulse, net_impulse_symmetry_index, fp1_peak_force, fp2_peak_force,
                               peak_force_symmetry_index, fp1_time_to_peak_force, fp2_time_to_peak_force, 
                               time_to_peak_force_symmetry_index, fp1_avg_rfd, fp2_avg_rfd, avg_rfd_symmetry_index)
  jump_information$unilateral_variables <- variable_table
})
```

```{r phase_analyses, echo=FALSE}
observe({
  req(jump_information$bilateral_data)
  req(jump_information$jump_type == "cmj") # Only runs if we're dealing with CMJ
  
  data <- jump_information$bilateral_data
  starting_weight <- data[1, total_force]
  body_weight <- jump_information$body_weight
  sampling_frequency <- input$sampling_frequency
  maximum_force_index <- which.max(data[, total_force]) # Constrains the data to search between jump_start and peak force
  minimum_force_index <- which.min(data[1:maximum_force_index, total_force]) # Prevents it from grabbing takeoff by mistake
  unweight_end_index <- detect_index(data[minimum_force_index:nrow(data), total_force], # Finds the first point force rises to or above starting weight
                                     ~ .x >= starting_weight, .dir = "forward") + minimum_force_index - 2 # Final point below starting weight
  braking_end_index <- detect_index(data[(unweight_end_index + 1):nrow(data), net_impulse], # Finds first point where net impulse becomes positive
                                    ~ .x >= 0, .dir = "forward") + unweight_end_index - 1 # This is the end of the braking phase; final negative velocity
  unweight_duration <- unweight_end_index / sampling_frequency # These are all indexed to the start of the jump, so no need for further corrections
  braking_duration <- (braking_end_index - unweight_end_index) / sampling_frequency
  concentric_duration <- (nrow(data) - braking_end_index) / sampling_frequency
  variable_table <- data.table(unweight_duration, braking_duration, concentric_duration)
  
  jump_information$unweight_end_index <- unweight_end_index
  jump_information$braking_end_index <- braking_end_index
  jump_information$phase_variables <- variable_table
})
```

Column
----------
### Full Trial
```{r}
renderPlotly({
  req(jump_information$trial_data)
  
  sampling_frequency <- input$sampling_frequency
  trial_data <- jump_information$trial_data
  trial_data[, time := 1:nrow(trial_data)][, time := time / sampling_frequency]
  
  trial_plot <-plot_ly(trial_data, x = ~time, source = "plot_brush") %>%
    add_lines(y = ~fp1,
              name = "FP1") %>%
    add_lines(y = ~fp2,
              name = "FP2") %>%
    add_lines(y = ~total_force,
              name = "Total Force") %>%
    layout(xaxis = list(title = "Time", fixedrange = TRUE),
           yaxis = list(title = "Force", fixedrange = TRUE),
           dragmode = "select")
})
```

### Relevant Time Points
```{r}
renderPlotly({
  req(jump_information$offset_data)
  
  sampling_frequency <- input$sampling_frequency
  trial_data <- jump_information$offset_data
  trial_data[, time := 1:nrow(trial_data)][, time := time / sampling_frequency]
  
  plot_ly(trial_data, x = ~time) %>%
    add_lines(y = ~fp1,
              name = "FP1") %>%
    add_lines(y = ~fp2,
              name = "FP2") %>%
    add_lines(y = ~total_force,
              name = "Total Force") %>%
    layout(shapes = list(vline(jump_information$jump_start_index / sampling_frequency),
                         vline(jump_information$peak_force_index / sampling_frequency),
                         vline(jump_information$takeoff_index / sampling_frequency),
                         vline(jump_information$landing_index / sampling_frequency)),
           xaxis = list(title = "Time"),
           yaxis = list(title = "Force (N)"))
})
```

Column {.tabset data-width=300}
----------
### Sub Plots
```{r}
renderPlotly({
  req(jump_information$bilateral_data)
  
  sampling_frequency <- input$sampling_frequency
  bilateral_data <- jump_information$bilateral_data
  bilateral_data[, time := 1:nrow(bilateral_data)][, time := time / sampling_frequency]
  long_bilateral_data <- melt(bilateral_data, id.vars = "time", measure.vars = 3:6)
  
  force_plot <- plot_ly(bilateral_data, x = ~time, y = ~total_force) %>%
    add_lines(name = "Force")
  if(jump_information$jump_type == "cmj"){
    force_plot <- force_plot %>%
      layout(shapes = list(vline(jump_information$unweight_end_index / sampling_frequency),
                           vline(jump_information$braking_end_index / sampling_frequency)))
  }
  velocity_plot <- plot_ly(bilateral_data, x = ~time, y = ~velocity) %>%
    add_lines(name = "Velocity")
  if(jump_information$jump_type == "cmj"){
    velocity_plot <- velocity_plot %>%
      layout(shapes = list(vline(jump_information$unweight_end_index / sampling_frequency),
                           vline(jump_information$braking_end_index / sampling_frequency)))
  }
  power_plot <- plot_ly(bilateral_data, x = ~time, y = ~power) %>%
    add_lines(name = "Power")
  if(jump_information$jump_type == "cmj"){
    power_plot <- power_plot %>%
      layout(shapes = list(vline(jump_information$unweight_end_index / sampling_frequency),
                           vline(jump_information$braking_end_index / sampling_frequency)))
  }
  subplot(force_plot, velocity_plot, power_plot, shareX = TRUE, shareY = FALSE, nrows = 3) %>%
    layout(xaxis = list(title = "Time"))
})
```

### Trial Information
```{r}
options(knitr.table.format = "html")
tableOutput("variable_table")
output$variable_table <- function(){
  req(jump_information$bilateral_variables)
  req(jump_information$unilateral_variables)
  
  variable_table <- cbind(jump_information$bilateral_variables, jump_information$unilateral_variables)
  if(jump_information$jump_type == "cmj"){
    variable_table <- cbind(variable_table, jump_information$phase_variables)
    setcolorder(variable_table, c(1:14, 16:27, 15, 28:30))
    setnames(variable_table, c("Jump Height (FT)", "Jump Height (NI)", "Flight Time", "Net Impulse", "Takeoff Velocity",
                               "Peak Force", "Peak Velocity", "Peak Power", "Force @ Peak Power", "Velocity @ Peak Power",
                               "Time to Peak Force", "Avg RFD", "Contact Time", "RSI Mod",
                               "FP1 Net Impulse", "FP2 Net Impulse", "Net Impulse SI", "FP1 Peak Force",
                               "FP2 Peak Force", "Peak Force SI", "FP1 TTPF", "FP2 TTPF", "TTPF SI",
                               "FP1 Avg RFD", "FP2 Avg RFD", "Avg RFD SI", "Force @ Zero Velocity", "Unweight Duration",
                               "Braking Duration", "Concentric Duration"))
    long_table <- melt(variable_table, measure.vars = 1:ncol(variable_table), variable.name = "Variable", value.name = "Value")
  }
  else{
    setnames(variable_table, c("Jump Height (FT)", "Jump Height (NI)", "Flight Time", "Net Impulse", "Takeoff Velocity",
                               "Peak Force", "Peak Velocity", "Peak Power", "Force @ Peak Power", "Velocity @ Peak Power",
                               "Time to Peak Force", "Avg RFD", "Contact Time", "RSI Mod",
                               "FP1 Net Impulse", "FP2 Net Impulse", "Net Impulse SI", "FP1 Peak Force",
                               "FP2 Peak Force", "Peak Force SI", "FP1 TTPF", "FP2 TTPF", "TTPF SI",
                               "FP1 Avg RFD", "FP2 Avg RFD", "Avg RFD SI"))
    long_table <- melt(variable_table, measure.vars = 1:ncol(variable_table), variable.name = "Variable", value.name = "Value")
  }
  output_table <- kable(long_table, digits = 3, col.names = NULL) %>%
    kable_styling("striped") %>%
    pack_rows("Bilateral Variables", 1, 14, label_row_css = "background-color: #1d89ff; color: #fff;") %>%
    pack_rows("Unilateral Variables", 15, 26, label_row_css = "background-color: #1d89ff; color: #fff;")
  if(jump_information$jump_type == "cmj"){
    output_table <- output_table %>%
      pack_rows("Phase-Related Variables", 27, 30, label_row_css = "background-color: #1d89ff; color: #fff;")
  }
  output_table
}
```